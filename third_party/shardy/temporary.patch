diff --git a/shardy/dialect/sdy/transforms/propagation/debugging/source_sharding.cc b/shardy/dialect/sdy/transforms/propagation/debugging/source_sharding.cc
index 3884ae6..0d207e7 100644
--- a/shardy/dialect/sdy/transforms/propagation/debugging/source_sharding.cc
+++ b/shardy/dialect/sdy/transforms/propagation/debugging/source_sharding.cc
@@ -346,14 +346,7 @@ void SourceShardingHandler::operator()(function_ref<void()> transform,
     llvm_unreachable("unknown EdgeSource");
   };
   auto updateEdgeMap = [&](AxisRefAttr newAxisRef, Value value) {
-    // Axis may not be in the map for region ops like `ManualComputationOp`
-    // where the `out_sharding` refers to a manual axis, but the body's
-    // `ReturnOp` doesn't have the manual axis.
-    auto it = axisToEdgeSourceMap.find(newAxisRef);
-    if (it == axisToEdgeSourceMap.end()) {
-      return;
-    }
-    EdgeSource source = it->getSecond();
+    EdgeSource source = axisToEdgeSourceMap.at(newAxisRef);
     if (mappings->debugEdgeSourceSharding) {
       mappings->valueToEdgeSourceMap[value][newAxisRef] = source;
     }
@@ -376,11 +369,7 @@ void SourceShardingHandler::operator()(function_ref<void()> transform,
       }
       for (auto [oldDimSharding, newDimSharding] : llvm::zip_equal(
                oldSharding.getDimShardings(), newSharding.getDimShardings())) {
-        // Skip if the sharding is empty or didn't change. The sharding may
-        // be empty when data flow ops are added for the block arguments of
-        // `ManualComputationOp`s, where the `in_sharding` only refers to
-        // manual axes.
-        if (newDimSharding.emptyAxes() || oldDimSharding == newDimSharding) {
+        if (oldDimSharding == newDimSharding) {
           continue;
         }
         const int oldDimShardingSize = oldDimSharding.getAxes().size();
diff --git a/shardy/dialect/sdy/transforms/propagation/debugging/test/sharding_origins.mlir b/shardy/dialect/sdy/transforms/propagation/debugging/test/sharding_origins.mlir
index a97d04c..a9309ae 100644
--- a/shardy/dialect/sdy/transforms/propagation/debugging/test/sharding_origins.mlir
+++ b/shardy/dialect/sdy/transforms/propagation/debugging/test/sharding_origins.mlir
@@ -150,38 +150,6 @@ func.func @manual_computation_no_manual_axes(%arg0: tensor<32x32x32xf32>) -> ten
   return %2: tensor<32x32x32xf32>
 }
 
-// TODO(b/381281685): save the changes to the in/out shardings on the
-// ManualComputationOp.
-// CHECK-LABEL: manual_computation_manual_axes
-// CHECK-SAME:    %arg0: tensor<32x32x32xf32> {sdy.origin_sharding = {a = "mc_1_input: 0", b = "mc_1_input: 0"},
-// CHECK-SAME:                                 sdy.sharding = #sdy.sharding<@mesh, [{"a", ?}, {"b", ?}, {?}]>}
-// CHECK-SAME:    -> (tensor<32x32x32xf32> {sdy.origin_sharding = {a = "mc_1_output: 0", b = "mc_1_input: 0"},
-// CHECK-SAME:                              sdy.sharding = #sdy.sharding<@mesh, [{"a", ?}, {"b", ?}, {?}]>}) {
-func.func @manual_computation_manual_axes(%arg0: tensor<32x32x32xf32>) -> tensor<32x32x32xf32> {
-  // CHECK-NEXT: %[[SUB:.*]] = stablehlo.subtract %arg0, %arg0 {sdy.origin_sharding = {a = "mc_1_input: 0", b = "mc_1_input: 0"},
-  // CHECK-SAME:                                                sdy.sharding = #sdy.sharding_per_value<[<@mesh, [{"a", ?}, {"b", ?}, {?}]>]>}
-  // CHECK-NEXT: %[[MC:.*]] = sdy.manual_computation(%[[SUB]])
-  // CHECK-SAME:   in_shardings=[<@mesh, [{"a", ?}, {"b", ?}, {?}]>]
-  // CHECK-SAME:   out_shardings=[<@mesh, [{"a", ?}, {"b", ?}, {?}]>]
-  // CHECK-SAME:   manual_axes={"a"} (%arg1: tensor<16x32x32xf32>) {
-  // CHECK-NEXT:   %[[ADD:.*]] = stablehlo.add %arg1, %arg1 {
-  // CHECK-SAME:     sdy.origin_sharding = {b = "mc_1_input: 0"},
-  // CHECK-SAME:     sdy.sharding = #sdy.sharding_per_value<[<@mesh, [{?}, {"b", ?}, {?}]>]>}
-  // CHECK-NEXT:   sdy.return %[[ADD]]
-  // CHECK-NEXT: } {sdy.origin_sharding_name = "mc_1"}
-  // CHECK-NEXT: %[[SUB_2:.*]] = stablehlo.subtract %[[MC]], %[[MC]] {
-  // CHECK-SAME:   sdy.origin_sharding = {a = "mc_1_output: 0", b = "mc_1_input: 0"},
-  // CHECK-SAME:   sdy.sharding = #sdy.sharding_per_value<[<@mesh, [{"a", ?}, {"b", ?}, {?}]>]>}
-  // CHECK-NEXT: return %[[SUB_2]]
-  %0 = stablehlo.subtract %arg0, %arg0 : tensor<32x32x32xf32>
-  %1 = sdy.manual_computation(%0) in_shardings=[<@mesh, [{"a", ?}, {"b", ?}, {?}]>] out_shardings=[<@mesh, [{"a", ?}, {?}, {?}]>] manual_axes={"a"} (%arg1: tensor<16x32x32xf32>) {
-    %3 = stablehlo.add %arg1, %arg1 : tensor<16x32x32xf32>
-    sdy.return %3 : tensor<16x32x32xf32>
-  } : (tensor<32x32x32xf32>) -> tensor<32x32x32xf32>
-  %2 = stablehlo.subtract %1, %1 : tensor<32x32x32xf32>
-  return %2: tensor<32x32x32xf32>
-}
-
 
 // Show that when an axis came from multiple sources, we just use the first we
 // see left to right, from operands to results.
@@ -245,6 +213,10 @@ func.func @real_conflict_across_factors_diff_tensors_size(
 
 // TODO(b/379279614): support ops with multiple results.
 
+// TODO(b/379279617): After `ManualComputationOp` implements the
+// `ShardableDataFlowOpInterface`, add a test for manual computation with
+// manual axes.
+
 // TODO(b/379279614): add test for while loop with multiple results, need to make
 // sure the origin sharding info is preserved after sinking the dataflow edge
 // ops.
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index c0df38c..95eedff 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "f67ba5855278401728413431216dda5d370ac2e0"
-    LLVM_SHA256 = "11b0bf49f2cbf34b951ec940979290b57833bbccb74ea3a9ad379123ce229870"
+    LLVM_COMMIT = "92a15dd7482ff4e1fae7a07f888564e5b1d53eee"
+    LLVM_SHA256 = "f1db765cbe004140d66107cad99d7f19d37e0b74646bdba217d1135b3bb86cb2"
 
     tf_http_archive(
         name = name,
